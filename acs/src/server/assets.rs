//! Embedded static assets for the web UI.

use axum::body::Body;
use axum::http::{header, Request, Response, StatusCode};
use rust_embed::RustEmbed;

/// Embedded web assets from the `web/` directory.
#[derive(RustEmbed)]
#[folder = "web/"]
pub struct WebAssets;

/// Serve embedded static files.
///
/// Lookup order:
/// 1. Exact file match (e.g. "style.css", "favicon.ico")
/// 2. Root/empty path → serve `index.html`
/// 3. Path without file extension → try `{path}/index.html`, then fall back to root `index.html`
/// 4. Everything else → 404
pub async fn serve_embedded(req: Request<Body>) -> Response<Body> {
    let path = req.uri().path().trim_start_matches('/');
    let path = if path.is_empty() { "index.html" } else { path };

    // 1. Exact file match
    if let Some(content) = WebAssets::get(path) {
        let mime_type = mime_guess::from_path(path)
            .first_or_octet_stream()
            .to_string();

        return Response::builder()
            .status(StatusCode::OK)
            .header(header::CONTENT_TYPE, mime_type)
            .body(Body::from(content.data.to_vec()))
            .unwrap();
    }

    // 2. Path without file extension — try {path}/index.html, then root index.html
    let last_segment = path.rsplit('/').next().unwrap_or(path);
    if !last_segment.contains('.') {
        let nested = format!("{}/index.html", path);
        if let Some(content) = WebAssets::get(&nested) {
            return Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_TYPE, "text/html")
                .body(Body::from(content.data.to_vec()))
                .unwrap();
        }

        if let Some(index) = WebAssets::get("index.html") {
            return Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_TYPE, "text/html")
                .body(Body::from(index.data.to_vec()))
                .unwrap();
        }
    }

    // 3. Not found
    Response::builder()
        .status(StatusCode::NOT_FOUND)
        .header(header::CONTENT_TYPE, "text/plain")
        .body(Body::from("Not Found"))
        .unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use axum::http::Request;
    use http_body_util::BodyExt;

    async fn body_string(body: Body) -> String {
        let bytes = body.collect().await.unwrap().to_bytes();
        String::from_utf8(bytes.to_vec()).unwrap()
    }

    #[tokio::test]
    async fn test_serve_index_html_for_root() {
        if WebAssets::get("index.html").is_none() {
            // index.html is generated by the frontend build; skip when absent.
            return;
        }

        let req = Request::builder()
            .uri("/")
            .body(Body::empty())
            .unwrap();

        let response = serve_embedded(req).await;

        assert_eq!(response.status(), StatusCode::OK);
        let content_type = response
            .headers()
            .get(header::CONTENT_TYPE)
            .unwrap()
            .to_str()
            .unwrap();
        assert!(content_type.contains("text/html"));
    }

    #[tokio::test]
    async fn test_serve_existing_file() {
        if WebAssets::get("openapi.yaml").is_none() {
            return;
        }

        let req = Request::builder()
            .uri("/openapi.yaml")
            .body(Body::empty())
            .unwrap();

        let response = serve_embedded(req).await;

        assert_eq!(response.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_serve_unknown_asset_returns_404() {
        for asset in &["/nonexistent.js", "/missing.css", "/favicon.png"] {
            let req = Request::builder()
                .uri(*asset)
                .body(Body::empty())
                .unwrap();
            let response = serve_embedded(req).await;
            assert_eq!(
                response.status(),
                StatusCode::NOT_FOUND,
                "Missing asset {} should 404",
                asset
            );
        }
    }

    #[tokio::test]
    async fn test_serve_nonexistent_returns_404() {
        let req = Request::builder()
            .uri("/nonexistent.file")
            .body(Body::empty())
            .unwrap();

        let response = serve_embedded(req).await;

        assert_eq!(response.status(), StatusCode::NOT_FOUND);
        let body = body_string(response.into_body()).await;
        assert_eq!(body, "Not Found");
    }

    #[tokio::test]
    async fn test_extensionless_path_falls_back_to_index_html() {
        if WebAssets::get("index.html").is_none() {
            // index.html is generated by the frontend build; skip when absent.
            return;
        }

        // A path without a file extension that doesn't match a nested
        // index.html should fall back to the root index.html.
        let req = Request::builder()
            .uri("/some-unknown-route")
            .body(Body::empty())
            .unwrap();

        let response = serve_embedded(req).await;

        assert_eq!(response.status(), StatusCode::OK);
        let content_type = response
            .headers()
            .get(header::CONTENT_TYPE)
            .unwrap()
            .to_str()
            .unwrap();
        assert!(content_type.contains("text/html"));
    }

    #[tokio::test]
    async fn test_mime_type_detection() {
        if WebAssets::get("index.html").is_none() {
            // index.html is generated by the frontend build; skip when absent.
            return;
        }

        let req = Request::builder()
            .uri("/index.html")
            .body(Body::empty())
            .unwrap();

        let response = serve_embedded(req).await;

        assert_eq!(response.status(), StatusCode::OK);
        let content_type = response
            .headers()
            .get(header::CONTENT_TYPE)
            .unwrap()
            .to_str()
            .unwrap();
        assert!(
            content_type.contains("text/html"),
            "Expected text/html, got: {}",
            content_type
        );
    }
}
